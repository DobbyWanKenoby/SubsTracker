# SubsTracker


Приложение "SubsTracker" - менеджер подписок и регулярных платежей для iOS.

**Используемая архитектура:** MVC + Координаторы/Микросервисы на основе SwiftCoordinatorsKit

# Описание SwiftCoordinatorsKit

> SwiftCoordinatorsKit находится в стадии разработки и еще не выделен в отдельный проект. Вся документация на ведется в данном репозитории.

**SwiftCoordinatorsKit** (SCK) позволяет добавить в проект Координаторы, главная цель которых - обеспечение максимально низкой связанности между элементами приложения (в частности между вью контроллерами). Координаторы могут брать на себя большую часть задач, за решение которых часто отвечают вью контроллеры, в то числе управление отображением сцен и передачу между ними данных. Таким образом сцены становятся независимыми друг от друга, так как работают через "посредников" - координаторов.

## Возможности координаторов

**Координатор** - это экземпляр класса, подписанного на один или несколько протоколов. Координаторы обязательно выполняются следующую задачу:

- Хранение иерархии координаторов (протокол `Coordinator`).
	
	Координаторы реализуют структуру данных "Дерево", где у каждого координатора может быть один родитель и произвольное количество сыновей. Обычно приложение имеет один главный координатор приложения (например `ApplicationCoordinator`) и множество дочерних, каждый из которых имеет свое множество дочерних координаторов, и т.д.

Также координаторы (в зависимости от протоколов, на которые они подписаны) могут выполнять следующие задачи:

1. Роутинг - управление логикой отображения сцен (протокол `Presenter`).

	Координаторы определяют, какие сцены и в какой момент должны быть отображены.

2. Передача данных внутри приложения (между сценами и координаторами) (протокол `Transmitter`).

	Благодаря тому, что координаторы хранят ссылки друг на друга, обеспечивается передача данных внутри приложения.
	
	> **Пример**
	> 
	> Если на одном из экранов приложения создается некий объект, который должен быть распространен на другие экраны, то данные могут передаваться по иерархии координаторов, пока не достигнут места (или мест) назначения. 
	> 
	> 	Например, приложение "Заметки". Экран создания "Заметки" не должен создавать заметку, он должен лишь предоставлять графический интерфейс для ее создания. После нажатия на кнопку "Сохранить" сущность "Заметка" упаковывается в специальный объект и отправляется по иерархии координаторов. При достижении экрана со списком заметок - она добавляется в него, а при достижении координатора, обеспечивающего сохранение заметок - она сохраняется в долговременное хранилище.

3. Микросервисы (протокол `ActionService`).

	Микросервис предназначен для решения конкретного круга задач, например:
	* обеспечение сохранения и загрузки определенных данных. Где именно эти данные будут храниться - ответственность микросервиса, важно, что он получив запрос - производит необходимые действия (сохраняет или загружает данные) и при необходимости отправляет ответ.
	* работа с нотификациями;
	
	и т.д.
	
	Микросервис находится в иерархии кординаторов, и когда к нему через Трансмиттеры прилетает запрос, то он отрабатывает его и при необходимости отвечает.


## Координаторы и потоки (flow) 

Координатор создается, когда в приложении необходимо выделить решение некоторой задачи. В контексте SCK такие задачи называются **потоками** (flow). Задачи - это условное наименование решаемых задач и в практике не используется при написании программного кода (за исключением названия методов `startFlow` и `finishFlow`). 

> **Пример**
> 
> Координатор `ApplicationCoordinator` может решать задачу обеспечения работы приложеняи в целом, в частности определения стартового экрана (в завиисмости от того, залогинен ли пользователь), загрузку вспомогательных библиотек и т.д. Образно говоря, он создает поток `Application`.
> 
> Координатор `AuthCoordinator` (будет дочерним по отношению к `ApplicationCoordinator`) может обеспечивать работу авторизированного пользователя и предоставлять доступ к соответствующим сценам (главынй экран приложения, экран настроек и т.д.).
> 
> Координатор `NotAuthCoordinator` (будет дочерним по отношению к `ApplicationCoordinator`) может обеспечивать работу неавторизированного пользователя и предоставлять доступ к соответствующим сценам (экран авторизации, регистрации и т.д.).

Дочерние координаторы функционируют в рамках родительского потока и создают свой собственный.

## Использование Координаторов


### protocol Coordinator

Базовый протокол, на который должен быть подписан любой Координатор. Его единственная задача - обеспечить хранение древовидной структуры координаторов.

#### Доступные элементы протокола
- Свойство ```init(```

Пример использования

```swift
class TestCoordinator: Coordinator {}

\\ создание координатора
let mainCoordinator = TestCoordinator()
let childcoordinator = TestCoordinator(rootCoordinator: mainCoordinator)

\\ доступные свойства
mainCoordinator.rootCoordinator \\ nil
childcoordinator.rootCoordinator \\ TestCoordinator

mainCoordinator.childCoordinators \\ Array of Coordinators
childcoordinator.childCoordinators \\ []
```




